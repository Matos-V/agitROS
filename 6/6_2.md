---
layout: default
title: Criando arquivos de launch 
parent: Arquivos de launch
nav_order: 2
---

# Criando arquivos de launch 
{: .no_toc }

Tendo visto como os arquivos de launch podem ser usados, estamos prontos para pensar como 
criá-los para nós mesmos. 
{: .fs-6 .fw-300 }

## Sumário
{: .no_toc .text-delta }

1. TOC
{:toc}
---

## Onde colocar arquivos de launch

Assim como todos os outros arquivos ROS, cada arquivo de launch deve estar associado a um
pacote específico. O esquema de nomeação serve para dar nomes aos arquivos de launch terminando
com `.launch`. O lugar mais simples para armazenar os arquivos de launch é diretamente no diretório
de pacotes. Quando estiver procurando por arquivos de launch, o `roslaunch` também buscará por
subdiretórios de cada diretório de pacote. Alguns pacotes, incluindo vários do núcleo de pacotes ROS, 
utilizam este recurso ao organizar os arquivos de launch dentro de um subdiretório próprio, usualmente 
chamado `launch`.


## Ingredientes Básicos

Os arquivos de launch mais simples consistem de um elemento raíz contendo diversos elementos `node`. 


### Inserind o o elemento raíz 

Arquivos de launch são documentos XML, e cada documento XML
deve ter exatamente um **elemento raíz**. Para os arquivos de launch do ROS< cada elemento raíz é definido por 
um par de etiquetas `launch`:


```
<launch>
...
</launch>
```

Todos os outros elementos de cada arquivo de launch devem ser inclusos entre estas etiquetas. 

### Nós de launching 

O coração de qualquer arquivo de launch é a coleção de elementos nós, que nomeia um único [nó](http://wiki.ros.org/roslaunch/XML/node) a ser executado. 
Um elemento nó se parece com:

```
<node
pkg="package-name"
type="executable-name"
name="node-name"
/>
```

>⚠️ A barra final próxima ao fim da etiqueta do nó é importante e fácil de ser esquecida.
> Ela indica que nenhuma etiqueta de fechamento (“`</node>`”) está por vir, e que cada elemento
> nó está completo. Parses do tipo XML são necessários para ser estrito com esse tipo de coisa. 
> Se você omitir essa barra, esteja preparado para erros do tipo: 
>```
> Invalid roslaunch XML syntax: mismatched tag
> ```
> You can also also write the closing tag explicitly:
> ```
> node pkg="..." type="..." name="..."></node>
> ```
> Na verdade, esta etiqueta de fechamento é necessária se o nó tem filhos, tais como  `remap` ou elementos
> `param`. Estes elementos são introduzidos nas seções 6.4 and 7.4, respectivamente. 
{: .fs-3 .code-example }

Um elemento `node` tem três atributos necessários:

- Os atributos `pkg` e `type`  identificam qual programa ROS deve ser executado para iniciar este nó.  
Estes são os mesmos que os dois argumentos de linha de comando do `rosrun`, especificando o nome do pacote
e o nome do executável, respectivamente. 
- O atributo `name` designa um nome par ao nó. Isso sobrescreve qualque rnome que o nó normalmente atribuiria a si mesmo
na sua chamada do `ros::init`.

> ⏩ Esse ato de sobrescrever elimina a informação quando ao nome provida ao  `ros::init`, 
> incluindo qualquer outra requisição que o nó possa ter feito para um nome anônimo.
> (Veja a Section 5.4.) 
> Para utilizar um nome anônimo de dentro de um arquivo [launch](http://wiki.ros.org/roslaunch/XML), use
> uma  substituição `anon` para o atributo do nome, do tipo: 
> ```
> name="$(anon base_name)"
> ```
> Note, no entanto, que múltiplos usos do mesmo nome base gerarão o mesmo nome anônimo.
> Isto significa que (a) podemos nos referir àquele nome em outras partes do arquivo de launch, 
> mas (b) devemos ser cuidadosos ao utilizar diferentes nomes base para cada nó que desejamos tornar anônimos.  
{: .fs-3 .code-example }

### Encontrando arquivos de log de um nó 

Uma diferença importante entre o `roslaunch` e a execução individual de cada nó utilizando o `rosrun` é que, 
por padrão, as saídas padrão dos nós executados é redirecionada para um arquivo de log, e não aparece no console<sup>[1](#fn1)</sup>.
O nome do arquivo de log é:

```
∼/.ros/log/run_id/node_name-number-stdout.log
```

O `run_id` é um identificador único gerado quando o master é iniciado. (Veja a página 72 para mais detalhes 
sobre como procurar pelo `run_id`atual.) Os números nestes arquivos são pequenos inteiros que numeram os nós. 
Por exemplo, executar o arquivo de launch na Lista 6.1 ebvua a saída padrão de dois dos seus nós para um 
arquivo de log com os seguintes nomes:

```
turtlesim-1-stdout.log
telep_key-3-stdout.log
```

Estes arquivos de log podem ser visualizados com um editor de texto à sua escolha. 

### Directing output to the console 
To override this behavior for a single node, use the `output` attribute in its `node` element:

```
output="screen"
```

Nodes launched with this attribute will display their standard output on screen instead
of in the log files discussed above. The example uses this attribute for the `subpose` node,
which explains why the `INFO` messages from this node appear on the console. It also
explains why this node is missing from the list of log files above.

In addition to the `output` attribute, which affects only a single node, we can also force
roslaunch to display output from all of its nodes, using the `--screen` command-line option:

```
roslaunch --screen package-name launch-file-name
```

>⚠️ If a program, when started from roslaunch, does not appear to be producing the
>output you expect, you should verify that that node has the `output="screen"` attribute set.
{: .fs-3 .code-example }

### Requesting respawning 
After starting all of the requested nodes, `roslaunch` monitors
each node, keeping track of which ones remain active. For each node, we can ask `roslaunch` to restart it when it terminates, by using a `respawn` attribute:

```
respawn="true"
```

This can be useful, for example, for nodes that might terminate prematurely, due to software crashes, hardware problems, or other reasons.

The respawn attribute is not really necessary in our example—All three programs are
quite reliable—but we include it for the `turtlesim_node` to illustrate how respawning
works. If you close the `turtlesim` window, the corresponding node will terminate. ROS
quickly notices this and, since that node is marked as a `respawn` node, a new `turtlesim`
node, with its accompanying window, appears to replace the previous one.

### Requiring nodes 

An alternative to `respawn` is to declare that a node is `required`:

```
required="true"
```

When a `required` node terminates, `roslaunch` responds by terminating all of the other active nodes and exiting itself. 
That sort of behavior might be useful, for example, for nodes
that (a) are so important that, if they fail, the entire session should be abandoned, and (b)
cannot be gracefully restarted by the `respawn` attribute.

The example uses the required attribute for the `turtle_teleop_key` node. If you close
the window in which the teleoperation node runs, roslaunch will kill the other two nodes
and exit.

>⚠️ Because their meanings conflict with one another, `roslaunch` will complain if you
> set both the `respawn` and `required` attributes for a single node
{: .fs-3 .code-example }

### Launching nodes in their own windows 

One potential drawback to using `roslaunch`,compared to our original technique of using `rosrun` 
in a separate terminal for each node, is that all of the nodes share the same terminal. 
This is manageable (and often helpful) for nodes that simply generate log messages, and do not
accept console input. For nodes that do rely on console input, as `turtle_teleop_key` does, it may 
be preferable to retain the separate terminals.

Fortunately, `roslaunch` provides a clean way to achieve this effect, using the `launchprefix` attribute of a node element:

```
launch-prefix="command-prefix"
```

The idea is that `roslaunch` will insert the given prefix at the start of the command line it
constructs internally to execute the given node. In `example.launch`, we used this attribute
for the teleoperation node:

```
launch-prefix="xterm -e"
```

Because of this attribute, this node element is roughly equivalent to this command:

```
xterm -e rosrun turtlesim turtle_teleop_key
```

As you may know, the `xterm` command starts a simple terminal window. The `-e` argument
tells `xterm` to execute the remainder of its command line (in this case, `rosrun turtlesim
turtle_teleop_key`) inside itself, in lieu of a new interactive shell. The result is that `turtle-
_teleop_key`, a strictly text-based program, appears inside a graphical window.

> ⏩The `launch-prefix` attribute is, of course, not limited to `xterm`. It can also be useful for 
> [debugging](http://wiki.ros.org/rqt_console) (via `gdb` or `valgrind`), or for lowering the scheduling priority of a process (via `nice`).
{: .fs-3 .code-example }

____
<a name="fn1">1</a> In the current version of `roslaunch`, output on standard error—notably including console outputs of
`ERROR-` and `FATAL-level` log messages—appears on the console, rather than in log files. However, a comment in the `roslaunch`
source code notes that this behavior may be changed in the future.
