---
layout: default
title: Um programa cliente
parent: Serviços
nav_order: 3
---
# Um programa cliente
{: .no_toc }

## Sumário
{: .no_toc .text-delta }

1. TOC
{:toc}
---

Chamar serviços a partir da linha de comando é conveniente para explorar e para coisas
que só precisam ser feitas ocasionalmente, mas claro é muito mais útil ser capaz de chamar serviços
a partir do seu [código](http://wiki.ros.org/ROS/Tutorials/WritingServiceClient(c++)).
A [Lista 8.1](#lista-81) mostra um exemplo curto de como fazer isso. Esse exemplo ilustra
todos os elementos básicos de um programa cliente de serviço. 

#### **Lista 8.1**
{: .no_toc }
##### Um programa chamado `spawn_turtle.cpp` que chama um serviço. 
{: .no_toc }
```
// This program spawns a new turtlesim turtle by calling
// the appropriate service.
#include <ros/ros.h>

// The srv class for the service.
#include <turtlesim/Spawn.h>

int main(int argc, char ∗∗argv){
ros::init(argc, argv, "spawn_turtle");
ros::NodeHandle nh;

// Create a client object for the spawn service. This
// needs to know the data type of the service and its
// name.
ros::ServiceClient spawnClient
   = nh.serviceClient <turtlesim::Spawn>("spawn");

// Create the request and response objects.
turtlesim::Spawn::Request req;
turtlesim::Spawn::Response resp;

// Fill in the request data members.
req.x = 2;
req.y = 3;
req.theta = M_PI/2;
req.name = "Leo";

// Actually call the service. This won't return until
// the service is complete .
bool success = spawnClient.call(req, resp);

// Check for success and use the response.
if(success){
ROS_INFO_STREAM("Spawned a turtle named "
  << resp.name);
}else{
ROS_ERROR_STREAM("Failed to spawn.");
}

}
```

## Declarando os tipos de requisição e resposta

Assim como tipos de mensagem (relembre a Seção 3.3.1), 
todo dado de serviço tem um arquivo de cabeçalho C++ 
que precisamos incluir: 

```
#include <package_name/type_name.h>
```

In the example, we say

```
#include <turtlesim/Spawn.h>
```

para incluir a definição de uma classe chamada `turtlesim::Spawn`, que define o tipo de dado —
incluindo tanto as partes de requisição como de resposta — do serviço que queremos chamar.  

## Criando um objeto cliente 

Depois de inicializar-se como um nó (ao chamar o `ros::init` e criar um objeto `NodeHandle`),
nosso programa deve criar um objeto do tipo `ros::ServiceClient`, cujo trabalho é na verdade
executar a chamada de serviço. A declaração de um `ros::ServiceClient` se parece com:

```
ros::ServiceClient client = node_handle.serviceClient<service_type>(service_name);
```

Essa linha tem três partes importantes. 

- O `node_handle` é o objeto `ros::NodeHandle` usual. Estamos chamando o seu método `serviceClient`
- O `service_type` é o nome do objeto de serviço definido no arquivo de cabeçalho que incluímos acima. 
Neste exemplo, é o `turtlesim::Spawn`.
- O `service_name` é uma string que nomeia o serviço que queremos chamar. Esse deveria ser um nome relativo, 
mas também pode ser um nome global. O exemplo usa o nome relativo "spawn". 

Por padrão, criar esse objeto é relativamente econômico porque não faz muito, exceto guardar os detalhes sobre
o serviço que precisaremos chamar depois. 

> ⚠️ Note que criar um `ros::Publisher` não requer um tamanho de file, ao contrário do análogo `ros::ServiceClient`.
Essa diferença ocorre porque chamadas de serviço não retornam até que a resposta chegue. Pelo fato do cliente esperar para que
a chamada de serviço seja completa, não há necessidade de manter uma fila de chamadas de serviço de saída. 
{: .fs-3 .code-example }

## Criando objetos de requisição e resposta 

Uma vez que o `ros::ServiceClient` esteja construído, a próxima etapa 
é criar um objeto de requisição que contém os dados a serem enviados ao servidor. 
O cabeçalho que incluímos acima contém classes separadas para as partes de resposta
e requisição do tipo de dado de serviço, chamado `Request` e `Response`, respectivamente. 
Estas classes devem ser referenciadas por meio do nome do pacote e do tipo de serviço da seguinte forma:

```
package_name::service_type::Request
package_name::service_type::Response
```

Cada uma dessas classes tem dados membros que são compatíveis com os campos do tipo de serviço. 
(Lembre-se que a saída do `rossrv` pode listar estes campos e seus tipos de dados para nós.) Esses
campos são mapeados para tipos C++ da mesma forma que os campos de mensagem são. O construtor `Request`
provê valores padrão sem significado para estes campos, de modo que devemos designar um valor para cada
campo. No exemplo, nós criamos um objeto `turtlesim::Spawn::Request` e definimos valores para seus campos
`x`, `y`,`theta`, and `name`.

Precisaremos também de um objeto `Response` — no exemplo, um `turtlesim::Spawn::Response`— mas, já que 
esta informação deveria vir do servidos, não devemos tentar preencher seus membros de dados. 


> ⚠️ O cabeçalho do tipo de serviço também define uma única clase (uma struct na realidade) chamada
```
package_name::service_type
```
> que contém tanto dados `Request` e `Response` como membros. Um objeto dessa classe é usualmente
chamado `srv`. Se você preferir — assim como muitos autores de tutoriais online aparentemente fazem —
você pode passar um objeto dessa classe para o método `call` introduzido abaixo, ao invés de separar os 
objetos `Request` e `Response`.
{: .fs-3 .code-example }

## Calling the service
 Once we have a `ServiceClient`, a completed `Request`, and a `Response`,
we can actually call the service:

```
bool success = service_client.call(request, response)
```

This method does the actual work of locating the server node, transmitting the request
data, waiting for a response, and storing the response data the `Response` we provided.


The call method returns a boolean value that tells us if the service call completed successfully. Failures
can occur because of problems with the ROS infrastructure — for example, attempting to call a service
not offered by any node — or for reasons specific to an individual service. In the example, a failed
call most commonly indicates that another turtle already exists with the requested name.

> ⚠️ A common mistake is to fail to check the return value of `call`. This can lead to unexpected problems
if the service `call` fails. It takes only a minute or two to add code to
check this value and call `ROS_ERROR_STREAM` when the service call fails. It's
quite likely that this investment of time will be repaid with easier debugging in the
future.
{: .fs-3 .code-example }

> ⏩ By default, the process of finding and connecting to the server node occurs inside
the `call` method. This connection is used for that service call and then closed before
`call` returns. ROS also supports a concept of persistent service clients, in which the
`ros::ServiceClient` constructor establishes a connection to the server, which is then
reused for every subsequent call for that client object. A persistent service client can
be created by passing `true` for the second parameter of the constructor (which we've
allowed to default to false in the previous examples)
```
ros::ServiceClient client = node_handle.advertise<service_type>(
service_name, true);
```
> The use of persistent clients is mildly discouraged by the
[documentation](https://docs.ros.org/en/api/roscpp/html/classros_1_1NodeHandle.html),
because the performance gains tend to be rather small — The author's informal experiments showed an
improvement of only about 10% — and the resulting system can
be less robust to restarts or changes of the server node.
{: .fs-3 .code-example }

After the service call successfully completes, you access the response data from the
`Request` object that you passed to `call`. In the example, the response includes only an
echo of the `name` field from the request.

## Declaring a dependency
 That's all there is to the client code. However, to get `catkin_make`
to correctly compile a client program, we must be sure that the program's package
declares a dependency on the package that owns the service type. Such dependencies,
which are the same as those we needed for message types (recall Section 3.3.3), require
edits to `CMakeLists.txt` and to the manifest, `package.xml`. To compile the example
program, we must ensure that the `find_package` line in `CMakeLists.txt` mentions the `turtlesim` package:

```
find_package(catkin REQUIRED COMPONENTS roscpp turtlesim)
```
In `package.xml`, we should ensure that `build_depend` and `run_depend` elements exist
that name the package:

```
<build_depend>turtlesim</build_depend>
<run_depend>turtlesim</run_depend>
```

After completing these changes, the usual `catkin_make` should compile the program.
