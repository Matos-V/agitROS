# Relative names

The main alternative to providing a global name, which—as we’ve just seen—includes a complete specification 
of the namespace in which the name lives, is to allow ROS to supply a default namespace. A name that uses 
this feature is called a **relative graph resource name**, or simply a **relative name**. The characteristic 
feature of a relative name is that it lacks a leading slash (/). Here are some example relative names:

```
teleop_turtle 
turtlesim 
cmd_vel 
turtle1/pose 
run_id 
count_and_log/set_logger_level
```

The key to understanding relative names is to remember that relative names cannot be matched to specific graph 
resources unless we know the default namespace that ROS is using to resolve them.

**Resolving relative names** The process of mapping relative names to global names is actually quite simple. 
To resolve a relative name to a global name, ROS attaches the name of the current default namespace to the front 
of the relative name. For example, if we use the relative name `cmd_vel` in a place where the default namespace 
is `/turtle1`, then ROS resolves the name by combining the two:

IMAGEM 1

Relative names can also begin with a sequence of namespaces, which are treated as nested namespaces inside the 
default namespace. As an extreme example, if we use the relative name `g/h/i/j/k/l` in a place where the default 
namespace is `/a/b/c/d/e/f`, ROS performs this combination:

IMAGEM 2

The resulting global name is then used to identify a specific graph resource, just as though a global name had been 
specified originally

**Setting the default namespace** This default namespace is tracked individually for each node, rather than being a 
system-wide setting. If you don’t take any specific steps to set the default namespace, then ROS will, as you might 
expect, use the global namespace (/). The best and most common method for choosing a different default namespace for 
a node or group of nodes is to use `ns` attributes in a launch file. (See Section 6.3.) However, there are also a 
couple of mechanisms for doing this manually.

- Most ROS programs, including all C++ programs that call `ros::init`, accept a command line parameter called `__ns`, 
which specifies a default namespace for that program.

```
__ns:=default-namespace
```

- You can also set the default namespace for every ROS program executed within a shell, using an environment variable.

```
export ROS_NAMESPACE=default-namespace
```

This environment variable is used only when no other default namespace is specified by the `__ns` parameter.

**Understanding the purpose of relative names** Aside from the question how to determine the default namespace used for 
relative names, one other likely question is “Who cares?” At first glance, the concept of relative names appears to be 
just a shortcut to avoid typing the full global names every time. Although relative names do provide this kind of 
convenience, their real value is that they make it easier to build complicated systems by composing smaller parts. 

When a node uses relative names, it is essentially giving its users the ability to easily push that node and the 
topics it uses down into a namespace that the node’s original designers did not necessarily anticipate. This kind 
of flexibility can make the organization of a system more clear and, more importantly, can prevent name collisions 
when groups of nodes from different sources are combined. In contrast, every explicit global name makes it harder 
to achieve this kind of composition. Therefore, when writing nodes, it’s recommended to avoid using global names, 
except in the unusual situations where there is a very good reason to use them.
