---
layout: default
title: A publisher program
parent: Escrevendo programas no ROS
nav_order: 3
---

# A publisher program
{: .no_toc }

## Sumário
{: .no_toc .text-delta }

1. TOC
{:toc}
---

The `hello` program from the previous section showed how to compile and run a simple ROS program. That program was useful as an introduction to `catkin`, but, like all "Hello, World!" programs, it didn't do anything useful. In this section, we'll look at [a program that interacts with ROS a bit more](http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber(c++)).
Specifically, we'll see how to send randomly-generated velocity commands to a `turtlesim` turtle, causing it to wander aimlessly. The brief C++ source code for the program, called
`pubvel`, appears as [Lista 3.4](#lista-34). This program shows all of the elements needed to publish messages from code.

#### **Lista 3.4**
{: .no_toc }
##### A program called `pubvel.cpp` that publishes randomly generated movement commands for a `turtlesim` turtle
{: .no_toc }
```
// This program publishes randomly−generated velocity
// messages for turtlesim.
#include <ros/ros.h>
#include <geometry_msgs/Twist.h> // For geometry_msgs : : Twist
#include <stdlib.h> // For rand () and RAND_MAX

int main(int argc , char ∗∗argv) {
// Initialize the ROS system and become a node.
ros::i n i t (argc, argv, "publish_velocity") ;
ros::NodeHandle nh;

// Create a publisher object.
ros::Publisher pub = nh.advertise<geometry_msgs::Twist>(
"turtle1/cmd_vel", 1000) ;

// Seed the random number generator .
srand (time (0)) ;

// Loop at 2Hz until the node is shut down.
ros::Rate rate(2);
while(ros::ok()) {
// Create and fill in the message. The other four
// fields, which are ignored by turtlesim, default to 0.
geometry_msgs::Twist msg;
msg.linear.x = double (rand())/double(RAND_MAX) ;
msg.angular.z = 2∗double (rand())/double(RAND_MAX) − 1;

// Publish the message.
pub.publish(msg) ;

// Send a message to rosout with the details.
ROS_INFO_STREAM("Sending␣random␣velocity␣command: "
<< "␣linear=" << msg.linear.x
<< "␣angular=" << msg.angular.z ) ;

// Wait until it's time for another iteration.
rate.sleep() ;
}
```

## Publishing messages

The main differences between `pubvel` and `hello` all stem from the need to publish messages.

### Including the message type declaration  
You'll likely recall from Section 2.7.2 that every
ROS topic is associated with a message type. Each message type has a corresponding
C++ header file. You'll need to `#include` this header for every message type used in your
program, with code like this:
```
#include <package_name/type_name.h>
```
Note that the package name should be the name of the package containing the message
type, and not (necessarily) the name of your own package. In pubvel, we want to publish
messages of type `geometry_msgs/Twist` — a type named Twist owned by a package
named `geometry_msgs` — so we need this line:
```
#include <geometry_msgs/Twist.h>
```
The purpose of this header is to define a C++ class that has the same data members as
the fields of the given message type. This class is defined in a namespace named after the
package. The practical impact of this naming is that when referring to message classes
in C++ code, you'll use the double colon (`::`) — also called the **scope resolution operator**
— to separate the package name from the type name. In our `pubvel` example, the header
defines a class called `geometry_msgs::Twist`.

### Creating a publisher object
The work of actually publishing the messages is done by an
object of class [`ros::Publisher`](http://wiki.ros.org/roscpp/Overview/Publishers%20and%20Subscribers).
A line like this creates the object we need:
```
ros::Publisher pub = node_handle.advertise<message_type>(topic_name, queue_size);
```
Let's have a look at each part of this line.

- The `node_handle` is an object of class `ros::NodeHandle`, one that you created near
the start of your program. We're calling the advertise method of that object.
- The `message_type` part inside the angle brackets — formally called the template
parameter — is the data type for the messages we want to publish. This should be the
name of the class defined in the header discussed above. In the example, we use the
`geometry_msgs::Twist` class.
- The `topic_name` is a string containing the name of the topic on which we want to
publish. It should match the topic names shown by `rostopic` list or `rqt_graph`, but
(usually) without the leading slash (/). We drop the leading slash to make the topic
name a **relative name**; Chapter 5 explains the mechanics and purposes of relative
names. In the example, the topic name is `turtle1/cmd_vel`.

> ⚠️ Be careful about the difference between the topic name and the If you accidentally
> swap these two, you'll get lots of potentially confusing compile errors.
{: .fs-3 .code-example }

- The last parameter to advertise is an integer representing the size of the **message
queue** for this publisher. In most cases, a reasonably large value, say 1000, is suitable.
If your program rapidly publishes more messages than the queue can hold, the oldest
unsent messages will be discarded.

> ⏩ This parameter is needed because, in most cases, the message must be transmitted to another node.
> This communication process can be time consuming, especially compared to the time needed to create messages.
> ROS mitigates this delay by having the publish method (see below) store the message
> in an "outbox" queue and return right away. A separate thread behind the
> scenes actually transmits the message. The integer value given here is the
> number of messages — and not, as you might guess, the number of bytes —
> that the message queue can hold.
> 
> Interestingly, the ROS client library is smart enough to know when the publisher and subscriber nodes are part of the same underlying process. In these
> cases, the message is delivered directly to the subscriber, without using any
> network transport. This feature is very important for making [**nodelets**](http://wiki.ros.org/nodelet)
> — that is, multiple nodes that can be dynamically loaded into a single process —
> efficient.
{: .fs-3 .code-example }

If you want to publish messages on multiple topics from the same node, you'll need to
create a separate `ros::Publisher` object for each topic.

> ⚠️  Be mindful of the lifetime of your `ros::Publisher` objects. Creating the publisher
> is an expensive operation, so it's a usually bad idea to create a new `ros::Publisher`
> object each time you want to publish a message. Instead, create one publisher for
> each topic, and use that publisher throughout the execution of your program. In
> `pubvel`, we accomplish this by declaring the publisher outside of the while loop.
{: .fs-3 .code-example }

### Creating and filling in the message object
Next, we create the message object itself. We
already referred to the message class when we created the `ros::Publisher` object. Objects
of that class have one publicly accessible data member for each field in the underlying
message type.

We used `rosmsg show` (Section 2.7.2) to see that the `geometry_msgs/Twist` message
type has two top-level fields (`linear` and `angular`), each of which contains three sub-fields
(x, y, and z). Each of these sub-fields is a 64-bit floating point number, called a double by
most C++ compilers. The code in [Lista 3.4](#lista-34) creates a `geometry_msgs::Twist` object and
assigns pseudo-random numbers to two of these data members:

```
geometry_msgs::Twist msg;
msg.linear.x = double(rand())/double(RAND_MAX);
msg.angular.z = 2*double(rand())/double(RAND_MAX) - 1;
```

This code sets the linear velocity to a number between 0 and 1, and the angular velocity to a
number between −1 and 1. Because `turtlesim` ignores the other four fields (`msg.linear.y`,
`msg.linear.z`, `msg.angular.x`, and `msg.angular.y`), we leave them with their default value,
which happens to be zero.


Of course, most message types have fields with types other than `float64`. Fortunately,
the mapping from ROS field types to C++ types works precisely the way you might [expect](http://wiki.ros.org/msg).
One fact that may not be obvious is that fields with array types — shown with
square brackets by `rosmsg show` — are realized as STL vectors in C++ code.

### Publishing the message
After all of that preliminary work, it is very simple to actually
publish the message, using the publish method of the `ros::Publisher` object. In the example, it looks like this:
```
pub.publish(msg);
```
This method adds the given `msg` the publisher's outgoing message queue, from which it
will be sent as soon as possible to any subscribers of the corresponding topic.

### Formatting the output

Although it's not directly related to publishing our velocity commands,
the `ROS_INFO_STREAM` line in [Lista 3.4](#lista-34) is worth a look. This is a more
complete illustration of what `ROS_INFO_STREAM` can do, because it shows the ability to insert data
other than strings — in this case, the specific randomly generated message fields — into the output.
Section 4.3 has more information about how `ROS_INFO_STREAM` works

## The publishing loop

The previous section covered the details of message publishing. Our `pubvel` example re-
peats the publishing steps inside a `while` loop to publish many different messages as time
passes. The program uses a two additional constructs to form this loop.

### Checking for node shutdown

The condition of `pubvel`'s while loop is:
```
ros::ok()
```
Informally, this function checks whether our program is still in "good standing" as a ROS
node. It will return true, until the node has some reason to shut down. There are a few
ways to get `ros::ok()` to return false:

- You can use `rosnode kill` on the node

- You can send an interrupt signal (`Ctrl-C`) to the program.

> ⏩ Interestingly, `ros::init()` installs a handler for this signal, and uses it to initiate
> a graceful shutdown. The impact is that `Ctrl-C` can be used to make `ros::ok()`
> `return false`, but does not immediately terminate the program. This can be
> important if there are clean-up steps — writing log files, saving partial results,
> `pubvel`, we accomplish this by declaring the publisher outside of the while loop.
> saying goodbye, etc — that should happen before the program exits.
{: .fs-3 .code-example }

- You can call, somewhere in the program itself,
```
ros::shutdown()
```

This function can be a useful way to signal that your node's work is complete from
deep within your code.

- You can start another node with the same name. This usually happens if you start a
new instance of the same program

### Controlling the publishing rate

The last new element of `pubvel` is its [use of a `ros::Rate` object:](http://wiki.ros.org/roscpp/Overview/Time).
```
ros::Rate rate(2);
```
This object controls how rapidly the loop runs. The parameter in its constructor is in units
of Hz, that is, in cycles per second. This example creates a rate object designed to regulate
a loop that executes two iterations per second. Near the end of each loop iteration, we call
the sleep method of this object:
```
rate.sleep();
```
Each call to the this method causes a delay in the program. The duration of the delay is cal-
culated to prevent the loop from iterating faster than the specified rate. Without this kind
of control, the program would publish messages as fast as the computer allows, which can
overwhelm publish and subscribe queues and waste computation and network resources.
(On the author's computer, an unregulated version of this program topped out around
6300 messages per second.)
You can confirm that this regulation is working correctly, using rostopic hz. For `pub vel`, the results should look similar to this:
```
average rate: 2.000
    min: 0.500s max: 0.500s std dev: 0.00006s window: 10
```
    
We can see that our messages are being published at a rate of two per second, with very
little deviation from this schedule.

> ⚠️ You might be thinking of an alternative to `ros::Rate` that uses a simple, fixed delay — 
> perhaps generated by `sleep` or `usleep` — in each loop iteration. The advantage of
> a `ros::Rate` object over this approach is that `ros::Rate` can account for the time
> consumed by other parts of the loop. If there is nontrivial computation to be done
> in each iteration (as we would expect from a real program), the time consumed by
> this computation is subtracted from the delay. In extreme cases, in which the real
> work of the loop takes longer than the requested rate, the delay induced by `sleep()`
> can be reduced to zero.
{: .fs-3 .code-example }

## Compiling `pubvel`

The process of building `pubvel` is mostly the same as for `hello:` Modify` CMakeLists.txt`
and `package.xml`, and then use `catkin_make` to build your workspace. There is, however,
one important difference from `hello`.

### Declaring message type dependencies

Because `pubvel` uses a message type from the
`geometry_msgs` package, we must declare a dependency on that package. This takes the
same form as the `roscpp` dependency discussed in Section 3.2.2. Specifically, we must
modify the `find_package` line in `CMakeLists.txt` to mention `geometry_msgs` in addition to `roscpp`:
```
find_package(catkin REQUIRED COMPONENTS roscpp geometry_msgs)
```
Note that we are modifying the existing `find_package` line, rather than creating a new one.
In `package.xml`, we should add elements for the new dependency:
```
<build_depend>geometry_msgs</build_depend>
<run_depend>geometry_msgs</run_depend>
```

> ⚠️ If you skip (or forget) this step, then `catkin_make` may not be able to find the
> header file `geometry_msgs/Twist.h`. When you see errors about missing header
> files, it's a good idea to verify the dependencies of your package.
{: .fs-3 .code-example }

## Executing `pubvel`

At last, we're ready to run `pubvel`. As usual, `rosrun` can do the job.
```
rosrun agitr pubvel
```
You'll also want to run a `turtlesim` simulator, so that you can see the turtle respond to the
motion commands that `pubvel` publishes:
```
rosrun turtlesim turtlesim_node
```
[Figura 3.1](#3.1) shows an example of the results.

<p align="center">
  <img src="https://user-images.githubusercontent.com/48807586/124123404-aa558380-da4d-11eb-90c4-5f0652605170.png" width="400"/><br>
  <i><b><a name="3.1"> Figura 3.1:</a></b> A <code>turtlesim</code> turtle responding to random velocity commands from <code>pubvel</code>.</i>
</p>
