#  Hello, ROS!

Now that we’ve created a package, we can start writing ROS programs

## A simple program

Listing 3.2 shows a ROS version of the canonical “Hello, world!” program. This source file, named hello.cpp, belongs in your package folder, right next to `package.xml` and `CMakeLists.txt`.

> *Some online tutorials suggest creating a src directory within your package directory to contain C++ source files. This additional organization might be helpful, especially for larger packages with many types of files, but it isn’t strictly necessary*

```
1 <?xml v e r si o n ="1.0"?>
2 <package>
3 <name>a gi t r </name>
4 <v e r si o n >0.0.1 </ v e r si o n >
5 <d e s c r i p t i o n >
6 Examples from A Gen tle I n t r o d u c ti o n t o ROS
7 </ d e s c r i p t i o n >
8 <m ai n t ai n e r em ail=" j o k a n e @ c s e . s c . edu">
9 Jason O' Kane
10 </m ain t aine r >
11 <l i c e n s e >TODO</l i c e n s e >
12 <build t o ol_depend>c a t ki n </build t o ol_depend>
13 <build_depend>geometry_msgs</build_depend>
14 <run_depend>geometry_msgs</run_depend>
15 <build_depend>t u r tl e sim </build_depend>
16 <run_depend>t u r tl e sim </run_depend>
17 </package>
```
**Listing 3.1:** The manifest (that is, `package.xml`) for this book’s agitr package.

We’ll see how to compile and run this program momentarily, but first let’s examine the code itself.

- The header file `ros/ros.h` includes declarations of the standard ROS classes. You’ll want to include it in every ROS program that you write.

- The `ros::init` function initializes the ROS client library. Call this once at the beginning of your program. The last parameter is a string containing the default name
of your node.

> *This default name can be overridden by a launch file (see page 87) or by a rosrun command line parameter (see page 23).*

- The `ros::NodeHandle` object is the main mechanism that your program will use to interact with the ROS system.Í4 Creating this object registers your program as a

```
1 // This i s a ROS version of the standard "he l lo , world"
2 // program .
3
4 // This header de f ines the standard ROS c lass es .
5 #i n cl u d e <r o s / r o s . h>
6
7 i n t main ( i n t argc , ch a r ∗∗ a rgv ) {
8 // I n i t i a l i z e the ROS system .
9 r o s : : i n i t ( argc , argv , " h ell o_ r o s " ) ;
10
11 // Es tab l ish t h i s program as a ROS node .
12 r o s : : NodeHandle nh ;
13
14 // Send some output as a log message .
15 ROS_INFO_STREAM( " Hell o , ␣ROS! " ) ;
16 }
```

**Listing 3.2:** A trivial ROS program called `hello.cpp`.

node with the ROS master. The simplest technique is to create a single NodeHandle object to use throughout your program.

> *Internally, the `NodeHandle` class maintains a reference count, and only registers a new node with the master when the first NodeHandle object is created. Likewise, the node is only unregistered when all of the NodeHandle objects have been destroyed. This detail has two impacts: First, you can, if you prefer, create multiple `NodeHandle` objects, all of which refer to the same node. There are occasionally reasons that this would make sense. An example of one such situation appears on page 129. Second, this means that it is not possible, using the standard `roscpp` interface, to run multiple distinct nodes within a single program.*

- The ROS_INFO_STREAM line generates an informational message. This message is sent to several different locations, including the console screen. We’ll see more details about this kind of log message in Chapter 4.

## Compiling the Hello program

How can you compile and run this program? This is handled by ROS’s build system, called catkin. There are four steps.

### Declaring dependencies 

First, we need to declare the other packages on which ours depends. For C++ programs, this step is needed primarily to ensure that `catkin` provides the C++ compiler with the appropriate flags to locate the header files and libraries that it needs. To list dependencies, edit the CMakeLists.txt in your package directory. The default version of this file has this line:

`find_package(catkin REQUIRED)`

Dependencies on other catkin packages can be added in a COMPONENTS section on this line:

`find_package(catkin REQUIRED COMPONENTS package-names)`

For the hello example, we need one dependency on a package called roscpp, which provides the C++ ROS client library. The required `find_package` line, therefore, is:

`find_package(catkin REQUIRED COMPONENTS roscpp)`

We should also list dependencies in the package manifest `(package.xml)`, using the build_depend and run_depend elements:

<build_depend>`package-name`</build_depend>

<run_depend>`package-name`</run_depend>

In our example, the hello program needs roscpp both at build time and at run time, so the manifest should contain:

<build_depend>`roscpp`</build_depend>

<run_depend>`roscpp`</run_depend>

However, dependencies declared in the manifest are not used in the build process; if youomit them here, you likely won’t see any error messages until you distribute your package to others who try to build it without having the required packages installed.

### Declaring an executable

Next, we need to add two lines to CMakeLists.txt declaring the executable we would like to create. The general form is

`add_executable(*executable-name source-files*)`

`target_link_libraries(*executable-name* ${catkin_LIBRARIES})`

The first line declares the name of the executable we want, and a list of source files that should be combined to form that executable. If you have more than one source file, list them all here, separated by spaces. The second line tells CMake to use the appropriate library flags (defined by the `find_package` line above) when linking this executable. If your package contains more than one executable, copy and modify these two lines for each executable you have.

In our example, we want an executable called hello, compiled from a single source file called hello.cpp, so we would add these lines to `CMakeLists.txt:`

`add_executable(hello hello.cpp)`

`target_link_libraries(hello ${catkin_LIBRARIES})`

For reference, Listing 3.3 shows a short `CMakeLists.txt` that suffices for our example. The default version of CMakeLists.txt created by `catkin_create_pkg` contains some commented-out guidance for a few other purposes; for many simple programs, something similar to the simple version shown here is enough.

### Building the workspace

Once your `CMakeLists.txt` is set up, you can build your workspace—including compiling all of the executables in all of its packages—using this command

`catkin_make`

Because it’s designed to build all of the packages in your workspace, this command must be run from your workspace directory. It will perform several configuration steps (especially the first time you run it) and create subdirectories called devel and build within your workspace. These two new directories contain build-related files like automatically-generated makefiles, object code, and the executables themselves. If you like, the devel and build subdirectories can safely be deleted when you’ve finished working on your package.

If there are compile errors, you’ll see them here. After correcting them, you can `catkin_make` again to complete the build process.

> *If you see errors from catkin_make that the header ros/ros.h cannot be found, or “undefined reference” errors on ros::init or other ROS functions, the most likely*

```
1 # What v e r si o n o f CMake i s needed ?
2 cmake_minimum_required (VERSION 2 . 8 . 3 )
3
4 # Name o f t h i s package .
5 p r o j e c t ( a g i t r )
6
7 # Find the c a t ki n b uil d system , and any o t h e r p ac k a ge s on
8 # which we depend .
9 find_p ack age ( c a t ki n REQUIRED COMPONENTS r o scpp )
10
11 # D e cl a r e our c a t ki n package .
12 c a tkin_p ack age ( )
13
14 # S p e ci f y l o c a t i o n s o f he ade r f i l e s .
15 i n c l u d e _ d i r e c t o r i e s ( i n cl u d e ${catkin_INCLUDE_DIRS } )
16
17 # D e cl a r e the e x e c u t a bl e , al o n g with i t s s o u r c e f i l e s . I f
18 # t h e r e a r e m ul ti pl e e x e c u t a bl e s , u se m ul ti pl e c o p i e s o f
19 # t h i s l i n e .
20 add_execu t able ( h e l l o h e l l o . cpp )
21
22 # S p e ci f y l i b r a r i e s a g ai n s t which t o l i n k . Again , t h i s
23 # l i n e sh ould be c o pi e d f o r each d i s t i n c t e x e c u t a bl e i n
24 # the package .
25 t a r g e t _ l i n k _ l i b r a r i e s ( h e l l o ${catkin_LIBRARIES } )
```

**Listing 3.3:** The `CMakeLists.txt` to build hello.cpp.

> *reason is that your CMakeLists.txt does not correctly declare a dependency on roscpp.*

**Sourcing** `setup.bash` The final step is to execute a script called setup.bash, which is created by catkin_make inside the devel subdirectory of your workspace:

`source devel/setup.bash`

This automatically-generated script sets several environment variables that enable ROS to find your package and its newly-generated executables. It is analogous to the global setup.bash from Section 2.2, but tailored specifically to your workspace. Unless the directory structure changes, you only need to do this only once in each terminal, even if you modify the code and recompile with `catkin_make.`

## **Executing the** hello program

When all of those build steps are complete, your new ROS program is ready to execute using rosrun (Section 2.6), just like any other ROS program. In our example, the command is:

`rosrun agitr hello`

The program should produce output that looks something like this:

[ INFO] [1416432122.659693753]: Hello, ROS!

Don’t forget to start `roscore` first: This program is a node, and nodes need a master to run correctly. By the way, the numbers in this output line represent the time—measured in seconds since January 1, 1970—when our ROS_INFO_STREAM line was executed.

> *This rosrun, along with some other ROS commands, may generate an error that looks like this:
`[rospack]` Error: stack/package `package-name` not found
Two common causes of this error are (a) misspelling the package name, and (b) failing to run the setup.bash for your workspace.*

